---
title: "Empirical data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Empirical data}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
library(GenomeAdmixR)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width = 6)
```

## Empirical data

By default, the package uses local ancestry data, where each locus can be 
uniquely traced back to one of the founding populations of the admixed focal population. If, however, you are more interested in admixing sequence data, the GenomeAdmixR package provides this optionality as well, where you can import your own sequences and admix those in a similar fashion.

```{r creating fake data}
  num_markers <- 100
  num_indiv <- 100
  chosen_markers <- 1:num_markers

  fake_input_data1 <- list()
  fake_input_data1$genomes <- matrix(data = sample(x = 1:2,
                                                   size = num_indiv * num_markers,
                                                   replace = T),
                                     nrow = num_indiv,
                                     ncol = num_markers)

  fake_input_data1$markers <- chosen_markers
  fake_input_data2 <- list()
  fake_input_data2$genomes <- matrix(data = sample(x = 3:4,
                                                   size = num_indiv * num_markers,
                                                   replace = T),
                                     nrow = num_indiv,
                                     ncol = num_markers)
  fake_input_data2$markers <- chosen_markers

  combined_data <- combine_input_data(input_data_list = list(fake_input_data1,
                                                             fake_input_data2),
                                      frequencies = c(0.5, 0.5),
                                      pop_size = 1000)
```

In this piece of code we create 'fake' sequencing data, however you can read in your own sequencing data using the function 'read_input_data'. After creating 
the fake input data, we combine both to a uniform hybrid swarm using the 
function 'combine input data'. 
The input data contains two data structures, similar to Plink style input data: the list contains a 'markers' object, which indicates the locations on the chromosome of the markers for which we have sequencing data. Locations can be 
both in bp and in Morgan (the function simulate_admixture_data transforms them 
to Morgan if necessary). The 'genomes' object contains a matrix where each row resembles a chromosome, and each column reflects a marker. Entries in the matrix reflect nucleotide bases transformed to numerics (e.g. a/c/t/g = 1/2/3/4, 
missing data = 0). 2 consecutive rows reflect an individual, such that rows 
1 & 2 are one individual, rows 3 & 4 etc.  
Now that we have the combined input data (which contains sequences of both our founding populations), we can use these to seed a simulation:

```{r simulate}
simulated_pop <- simulate_admixture_data(input_data = combined_data,
                                         pop_size = 1000,
                                         total_runtime = 100,
                                         morgan = 1,
                                         markers = chosen_markers,
                                         verbose = FALSE)
```
We have simulated here a population of 1000 individuals (initially randomly 
drawn from the sequences we created using combine_input_data), for 100 generations. 
The result is identical in structure to results from 'simulate_admixture' and we
can use the same visualisation and analytical devices:

```{r visualise}
plot_over_time(simulated_pop$frequencies, focal_location = 0.5)
plot_joyplot_frequencies(simulated_pop$frequencies, time_points = c(0, 50, 100))
```

Furthermore, we can also perform selection on a certain allele, where the 
location under selection (first entry in the selection matrix) is in Morgan.

```{r simulate selection}
selection_matrix <- matrix(NA, nrow = 1, ncol = 5)
selection_matrix[1, ] <- c(0.5, 1, 1.1, 1.2, 1)

# we expect allele 'a' to do well at 0.5 Morgan:
selected_pop <- simulate_admixture_data(input_data = combined_data,
                                         pop_size = 1000,
                                         total_runtime = 100,
                                         morgan = 1,
                                         select_matrix = selection_matrix,
                                         markers = chosen_markers,
                                         verbose = FALSE)
plot_over_time(selected_pop$frequencies, focal_location = 0.5)
```

