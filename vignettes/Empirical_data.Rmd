---
title: "Empirical data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Empirical data}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
library(GenomeAdmixR)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width = 6)
```

## Empirical data

By default, the package uses local ancestry data, where each locus can be 
uniquely traced back to one of the founding populations of the admixed focal 
population. 
If, however, you are more interested in admixing sequence data, the GenomeAdmixR 
package provides this optionality as well, where you can import your own 
sequences and admix those in a similar fashion.

```{r creating fake data}
  num_markers <- 100
  num_indiv <- 100
  chosen_markers <- 1:num_markers

  fake_input_data <- list()
  fake_input_data$genomes <- matrix(data = sample(x = 1:4,
                                                   size = num_indiv * 2 *
                                                          num_markers,
                                                   replace = T),
                                     nrow = num_indiv * 2,
                                     ncol = num_markers)

  fake_input_data$markers <- chosen_markers
  class(fake_input_data) <- "genomeadmixr_data"
```
Here, we create fake input data in absence of an example file. The data consists
of two components: a genome matrix and a vector with marker locations. The 
genome matrix has two rows per individual (one for each chromosome) and one 
column per molecular marker. The number of columns of the genome matrix should
match the length of the marker vector. Instead of using a/c/t/g, we use 
numerical notation, e.g. 1/2/3/4 (with missing data = 0).
Instead, you can also load sequence data from a VCF file (function 
\code{vcfR_to_genomeadmixr_data}) or from PLINK style data (function 
\code{ped_map_table_to_genomeadmixr_data}).
The loaded data can now be used as input for a simulation:

```{r simulate admix data}
simulated_pop <- simulate_admixture_data(input_data = fake_input_data,
                                         pop_size = 100,
                                         total_runtime = 100)
```
If you want to study admixture, you might have VCF data with individuals from 
multiple populations. GenomeAdmixR provides functionality to use this data as
seeding data as well, although we do ask you to prepare two distinct VCF files,
where each VCF contains the individuals from each population.
Because \code{simulate_admixture_data} only accepts a single input matrix, we 
can artifically create an initial hybrid input swarm by loading data from 
multiple VCF files, and then randomly sampling individuals from these datasets
in order to form the starting dataset. We can do so using the function
combine_input_data:
```{r creating fake data}
  num_markers <- 100
  num_indiv <- 100
  chosen_markers <- 1:num_markers

  fake_input_data1 <- list()
  fake_input_data1$genomes <- matrix(data = sample(x = 1:2,
                                                   size = num_indiv * 2 *
                                                          num_markers,
                                                   replace = T),
                                     nrow = num_indiv,
                                     ncol = num_markers)

  fake_input_data1$markers <- chosen_markers
  fake_input_data2 <- list()
  fake_input_data2$genomes <- matrix(data = sample(x = 3:4,
                                                   size = num_indiv * 2 *
                                                          num_markers,
                                                   replace = T),
                                     nrow = num_indiv,
                                     ncol = num_markers)
  fake_input_data2$markers <- chosen_markers

  combined_data <- combine_input_data(input_data_list = list(fake_input_data1,
                                                             fake_input_data2),
                                      frequencies = c(0.5, 0.5),
                                      pop_size = 1000)
```
We can use this input data as a starting point for a simulation again:
```{r simulate}
simulated_pop <- simulate_admixture_data(input_data = combined_data,
                                         pop_size = 1000,
                                         total_runtime = 100,
                                         morgan = 1,
                                         markers = chosen_markers,
                                         verbose = FALSE)
```
We have simulated here a population of 1000 individuals (initially randomly 
drawn from the sequences we created using combine_input_data), for 100 
generations. 
The result is identical in structure to results from 'simulate_admixture' and we
can use the same visualisation and analytical devices:

```{r visualise}
plot_over_time(simulated_pop$frequencies, focal_location = 0.5)
plot_joyplot_frequencies(simulated_pop$frequencies, time_points = c(0, 50, 100))
```

Furthermore, we can also perform selection on a certain allele, where the 
location under selection (first entry in the selection matrix) has to exist in
the original dataset.

```{r simulate selection}
selection_matrix <- matrix(NA, nrow = 1, ncol = 5)
selection_matrix[1, ] <- c(0.5, 1, 1.1, 1.2, 1)

# we expect allele 'a' to do well at 0.5 Morgan:
selected_pop <- simulate_admixture_data(input_data = combined_data,
                                         pop_size = 1000,
                                         total_runtime = 100,
                                         morgan = 1,
                                         select_matrix = selection_matrix,
                                         markers = chosen_markers,
                                         verbose = FALSE)
plot_over_time(selected_pop$frequencies, focal_location = 0.5)
```

# Migration
Sequence data can also be used to seed a simulation where two populations 
exchange migrants:

```{r migration}
class(fake_input_data1) <- "genomeadmixr_data"
class(fake_input_data2) <- "genomeadmixr_data"

migr_pop <- 
  simulate_admixture_migration_data(input_data_population_1 = fake_input_data1,
                                    input_data_population_2 = fake_input_data2,
                                    pop_size = c(100, 100),
                                    total_runtime = 100,
                                    migration_rate = 0.01)
```

# Using simulation data as input
Lastly, not only "true" sequencing data can be used as input, but also previous
output from GenomeAdmixR simulations. In order to so, output from previous 
simulations can be converted to genomeadmixr_data, either using pre-existing
molecular markers as used in the simulation, or by superimposing markers on 
new locations.

```{r from_simulation}
simulated_pop <- simulate_admixture(pop_size = 100, 
                                    total_runtime = 100)
prepared_pop  <- simulation_data_to_genomeadmixr_data(simulation_data = simulated_pop,
                                                      markers = seq(0, 1, length.out = 100))

simulated_pop2 <- simulate_admixture_data(input_data = prepared_pop,
                                          pop_size = 100,
                                          total_runtime = 100)
```